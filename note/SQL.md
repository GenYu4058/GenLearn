# 一条语句在MySQL里的执行过程

//TODO



# SQL无法命中索引的几种情况

**最左前缀原则**

MySQL中会帮助我们优化顺序，但是不能少索引字段

但是由于 MySQL 的查询优化器会自动调整 where 子句的条件顺序以使用适合的索引，所以 MySQL 不存在 where 子句的顺序问题而造成索引失效

**范围查询**
 mysql 会一直向右匹配直到遇到范围查询（>、<、between、like）就停止匹配。范围列可以用到索引，但是范围列后面的列无法用到索引。即，索引最多用于一个范围列，因此如果查询条件中有两个范围列则无法全用到索引

**like 语句的索引问题**
 如果通配符 % 不出现在开头，则可以用到索引，但根据具体情况不同可能只会用其中一个前缀
 在 like “value%” 可以使用索引，但是 like “%value%” 不会使用索引，走的是全表扫描

**不要在列上进行运算**
 如果查询条件中含有函数或表达式，将导致索引失效而进行全表扫描
 例如 select * from user where YEAR(birthday) < 1990
 可以改造成 select * from users where birthday <’1990-01-01′

**索引不会包含有 NULL 值的列**
 只要列中包含有 NULL 值都将不会被包含在索引中，复合索引中只要有一列含有 NULL 值，那么这一列对于此复合索引就是无效的。所以在数据库设计时不要让字段的默认值为 NULL



# 性能监控

show profile 查看sql语句运行时间

performance schema来更加容易的监控

show processlist 查看Mysl的服务一共有多少个连接

# 数据类型

1. 更小的通常更好
2. 简单就好
3. 尽量避免Null

> 磁盘预读：并不是用到哪个字节就读哪个字节，操作系统会将此数据相邻的数据也读进去。称之为“页”，如果不设置的话，默认为4kb
>

## char和varchar的区别（字符串类型）

char：

- 最大长度255；
- 会自动删除末尾的空格；
- 检索效率、写效率会比varchar高（以空间换时间）

应用场景：1、存储长度波动不大的数据，如MD5摘要。2、存储短字符串、经常更新的字符串。

varchar

- 使用最小的符合需求的长度
- varchar(n)n小于等于255使用额外一个字节保存长度，n>255使用额外两个字节保存长度。
- varchar(5)与varchar(255)保存同样的内容，硬盘存储空间相同，但是内存空间不同，是指定的大小。
- varchar在5.6版本之前变更长度，或者从255一下变更到255以上时，会导致锁表。

应用场景：1、存储长度波动较大的数据，如：文章，有的会很短有的会很长。2、字符串很少更新的场景，每次更新后都会重算并使用额外存储空间保存长度。3、适合保存多字节字符，如：汉子，特殊字符等。

BLOB和text类型

> 一般不会用，可以将文件路径存到数据库中
>

## 时间类型

datetime

- 占用8个字节
- 与时区无关，数据库底层时区配置，对datetime无效
- 可保存到毫秒
- 可保存时间范围大
- 不要使用字符串存储日期类型，占用空间大，损失日期类型函数的便捷性

timestamp（比较多）

- 占用4个字节
- 时间范围：1970-01-01到2038-01-19
- 精确到秒
- 采用整形存储
- 依赖数据库设置的时区
- 自动更新timestamp列的值

date

- 占用字节数比使用字符串、datetime、int存储要少，date类型只需要3个字节
- 使用date类型还可以利用日期时间函数进行日期之间的计算
- date类型用于保存1000-01-01到9999-12-31之间的日期

## 使用枚举类型替换字符串



# 三范式

设计关系型数据库时，遵从不同的规范要求，设计出合理的关系型数据库，这些不同的规范要求被称为不同的范式，各种范式呈递次规范，越高的范式数据库冗余越小。

目前关系型数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式（4NF）和第五范式（5NF，又称完美范式）。一般来说，数据库只需要满足第三范式就行了。

**第一范式：保证每列的原子性**

之前

![img](https://images2015.cnblogs.com/blog/801753/201601/801753-20160104213533903-1289288782.png)

之后

![img](https://images2015.cnblogs.com/blog/801753/201601/801753-20160104213917293-224191887.png)

**第二范式：保证一张表只描述一件事情**

之前

![img](https://images2015.cnblogs.com/blog/801753/201601/801753-20160104214722121-759747894.png)

之后

![img](https://images2015.cnblogs.com/blog/801753/201601/801753-20160104220504371-1664259281.png)

![img](https://images2015.cnblogs.com/blog/801753/201601/801753-20160104220514528-910792103.png)

![img](https://images2015.cnblogs.com/blog/801753/201601/801753-20160104220522293-1811707240.png)

**第三范式----保证每列都和主键直接相关**

之前

![img](https://images2015.cnblogs.com/blog/801753/201601/801753-20160104223715387-644453835.png)

之后

![img](https://images2015.cnblogs.com/blog/801753/201601/801753-20160104225332200-1352027219.png)

![img](https://images2015.cnblogs.com/blog/801753/201601/801753-20160104225343746-1036219025.png)

反范式（阿里规范，超过三张表，禁止使用join）

## 范式与反范式优缺点

范式优点

- 范式化的更新通常比反范式快
- 当数据较好的范式化后，很少或者没有重复的数据
- 范式化的数据比较小，可以放在内存中，操作比较快

范式缺点

- 通常需要进行关联

反范式优点

- 所有的数据都在同一张表中，可以避免关联
- 可以设计有效的索引

反范式缺点

- 表格内的数据冗余较多，删除数据时候会造成表有些有用的信息丢失

> 根据业务场景，混合使用范式与反范式



# 主键选择

**代理主键**

与业务无关的，无意义的数字序列

**自然主键**

事务属性中的自然唯一标识

推荐使用代理主键，因为不与业务耦合，因此更容易维护；一个大多数表，最好是全部表，通用的键策略能够减少需要编写的源码数量，减少系统的总体拥有成本

# 字符集选择

UTF8MB4

# 存储引擎的选择

存储引擎是数据文件的组织形式

默认innoDB存储引擎

innoDB

默认情况下，给索引进行加锁，在增删改查的时候的条件列是否是索引列，如果是就是行锁，如果不是就是表锁

MyISAM

![image-20200816224947752](SQL.assets/image-20200816224947752.png)

聚簇索引：数据文件和索引文件放在一起的是聚簇索引

非聚簇索引：数据文件和索引文件不放在一起的是非聚簇索引



memory：使用哈希索引，不能持久化，一关机，数据就没啦

# 分库分表

垂直切分

按照业务来拆分，将不同的表放到不同的物理服务器，这样请求会分散到不同的物理服务器，减少单个服务器压力。

水平切分

一张表里面，1万个字段，1-1000放到一个物理服务器，1000-2000放到一个物理服务器

# 执行计划

mysql执行计划.md

# 索引

## 索引类型

1. 主键索引
2. 普通索引
3. 组合索引
4. 全文索引
5. 唯一索引

问：为什么不用哈希表存储（memory存储引擎是用hash存储）**

1、利用hash存储的话需要将所有的数据文件添加到内存，比较耗费内存空间。

2、如果所有的查询都是等值查询，那么hash确实很快，但是实际工作中范围查找的数据更多，而不是等值查询，因此hash就不太适合了。

**问：为什么不用二叉树存储**

1、可能会发生一条腿长，一条腿短的情况，每个结点都是一次IO

**问：为什么不用平衡二叉树（AVL树）**

1、进行插入或者删除时，可能发生旋转操作。数据越多，会进行1-n次旋转。所以插入删除效率极低，查询操作会很高。

**问：为什么不用红黑树**

红黑树是AVL树变种，通过变色减少旋转成本，损失了一部分的查询性能，来增加插入删除性能。但还是会因为结点过深，而造成IO次数过多。

**问：为什么不用B树**

MySQL在读取数据的时候，磁盘预读，读取页的整数倍，（innoDB存储引擎默认读取16k，4页），假设指针和键值都不占用空间，但是数据会很占用空间。大部分的空间都被data占用。所以存储不了多少键值。

**问：为什么选用B+树**

B+树在B树的基础上做了优化，非叶子节点不再存储data，而是在最后一层叶子节点上存储。这样，每一层可以存储很多个键值。减少了树的高度。

**问：innodb和myisam区别**

虽然都是用B+数存储，但是myisam的索引文件和数据文件是分开的，所以叶子节点上存储的是具体数据的文件地址。而innodb的索引文件和数据文件用同一个文件，叶子节点上存储的就是具体的数据。

> 注意：Innodb是通过B+树结构对主键创建索引，然后叶子节点中存储记录，如果没有主键，那么会选择唯一键，如果没有唯一键，那么会生成一个6位的row_id作为主键。

**回表**

如果创建索引的键是其他字段，那么在叶子节点中存储的是该记录的主键，然后再通过主键索引找到对应的记录，叫做回表。

**覆盖索引**

要查询的值刚好是叶子节点中存储的主键，那么就没有必要回表，这种情况叫覆盖索引。

如果一个索引包含所有需要查询的字段的值，我们称之为覆盖索引

不是所有类型的索引都可以称为覆盖索引，覆盖索引必须要存储索引列的值

不同的存储实现覆盖索引的方式不同，不是所有的引擎都支持覆盖索引，memory不支持覆盖索引。

优点：

1. 索引条目通常远小于数据行大小，如果只需要读取索引，那么mysql就会极大的减少数据访问量。
2. 因为索引是按照列值顺序存储的，所以对于IO密集型的范围查询会比随机从磁盘读取每一行数据的IO要少的多。
3. 一些存储引擎如MyISAM在内存中只缓存索引，数据则依赖于操作系统来缓存，因此要访问数据需要一次系统调用，这可能会导致严重的性能问题。
4. 由于innodb的聚簇索引，覆盖索引对于Innodb表特别有用。



**最左匹配**

多个列同时创建索引，ABC列，如果只查询了BC列，那么就不会命中索引。

**索引合并**

//TODO

**索引下推**

where name ='' and age =''时，有两种方法

第一种，先把所有name=''的数据从存储引擎中找出来，再在server层里面过滤age条件的数据。

第二种，在存储引擎找name=''的数据时，就把age=''的值过滤掉。

而第二种就叫做索引下推。

**主键索引和唯一索引区别**

主键索引值不能为空，唯一索引的值可以为空。

## 索引优点

1. 大大减少了服务器需要扫描的数据量。
2. 帮助服务器避免排序和临时表
3. 将随机IO变成顺序IO

当数据长度很大的时候可以使用哈希索引

## **聚簇索引和非聚簇索引对比**

**聚簇索引：**不是单独的索引类型，而是一种数据存储方式，指的是数据行跟相邻的键值紧凑的存储在一起。

优点：

1. 可以把相关数据保存在一起
2. 数据访问更快，因为索引和数据保存在同一个树中
3. 使用覆盖索引扫描的查询可以直接使用页节点中的主键值

缺点：

1. 聚簇数据最大限度地提高了IO密集型应用的性能，如果数据全部在内存，那么聚簇索引就没有什么优势
2. 插入速度严重依赖于插入顺序，按照主键的顺序插入是最快的方式。
3. 更新聚簇索引列的代价很高，因为会强制将每个被更新的行移动到新的位置。
4. 基于聚簇索引的表在插入新行，或者主键被更新导致需要移动行的时候，可以面临页分裂的问题。
5. 聚簇索引可能导致全表扫描变慢，尤其是行比较稀疏，或者由于页分裂导致数据存储不连续的时候。



**非聚簇索引：**索引文件和数据文件分开存放。





**页分裂：**在插入数据的时候，如果叶节点空间不够用，则会分裂成两个节点。

**页合并：**在删除数据的时候，如果空间浪费严重，则会合并成一个节点。

> 因为有页分裂的存在，所以在迁移大量数据的时候，可以先把索引先关掉，再把数据迁移，迁移完成后，再把索引开启。这样效率会比较高。

## 索引优化











//todo mysql和oracle区别

//todo 索引，数据库引擎